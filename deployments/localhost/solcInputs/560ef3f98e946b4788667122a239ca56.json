{
  "language": "Solidity",
  "sources": {
    "contracts/01-AccessControl/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/******************************************************************************\\\n* @title Access Control\n* @author Evert Kors <evert@thx.network>\n* @notice Implement role-based access control.\n* \n* @dev\n* Implementations: \n* TMP-1 Access Control: https://github.com/thxprotocol/modules/issues/1\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/utils/EnumerableSet.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '../TMP/TMP1/LibAccessStorage.sol';\nimport '../TMP/TMP1/IAccessControl.sol';\nimport '../TMP/TMP1/IAccessControlEvents.sol';\nimport '../TMP/RelayReceiver.sol';\n\ncontract AccessControl is IAccessControl, IAccessControlEvents, RelayReceiver {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    /**\n     * @notice Checks if an address bears a given role.\n     * @param role Role to check account for.\n     * @param account Account to check the role for.\n     * @return if the account bears the role.\n     */\n    function hasRole(bytes32 role, address account) external view override returns (bool) {\n        return _hasRole(role, account);\n    }\n\n    /**\n     * @notice Gets the amount of members for a role.\n     * @param role Role to get the count for.\n     * @return the amount of members for the role.\n     */\n    function getRoleMemberCount(bytes32 role) external view override returns (uint256) {\n        return LibAccessStorage.roleStorage().roles[role].members.length();\n    }\n\n    /**\n     * @notice Gets the member address for a given role.\n     * @param role Role of the pool member.\n     * @param index Index of the pool member.\n     * @return member address.\n     */\n    function getRoleMember(bytes32 role, uint256 index) external view override returns (address) {\n        return LibAccessStorage.roleStorage().roles[role].members.at(index);\n    }\n\n    /**\n     * @notice Determines what role is required to manage the role.\n     * @param role Bytes32 array representing the role\n     * @return Bytes32 array of the administrative role for the given role.\n     */\n    function getRoleAdmin(bytes32 role) external view override returns (bytes32) {\n        return LibAccessStorage.roleStorage().roles[role].adminRole;\n    }\n\n    /**\n     * @notice Grants a role to a given account address.\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account that is given the role.\n     */\n    function grantRole(bytes32 role, address account) external override {\n        require(\n            _hasRole(LibAccessStorage.roleStorage().roles[role].adminRole, _msgSender()),\n            'AccessControl: sender must be an admin to grant'\n        );\n        _grantRole(role, account);\n    }\n\n    /**\n     * @notice Revokes the role for a given account address if sender is admin of the role.\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     */\n    function revokeRole(bytes32 role, address account) external override {\n        require(\n            _hasRole(LibAccessStorage.roleStorage().roles[role].adminRole, _msgSender()),\n            'AccessControl: sender must be an admin to revoke'\n        );\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @notice Renounces the role for a given account address if equal to sender address.\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     */\n    function renounceRole(bytes32 role, address account) external override {\n        require(account == _msgSender(), 'AccessControl: can only renounce roles for self');\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Checks if account bears role.\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     * @return if role member storage array contains the given account address.\n     */\n    function _hasRole(bytes32 role, address account) internal view virtual returns (bool) {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        return rs.roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Called in initialize methods.\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Called during initialization\n     * @param role Bytes32 array representing the role.\n     * @param adminRole Address of the role admin\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        emit RoleAdminChanged(role, rs.roles[role].adminRole, adminRole);\n        rs.roles[role].adminRole = adminRole;\n    }\n\n    /**\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        if (rs.roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        if (rs.roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/TMP/TMP1/LibAccessStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\nimport '@openzeppelin/contracts/utils/EnumerableSet.sol';\n\nlibrary LibAccessStorage {\n    // TODO test with conflicting storage (with other pools)\n    // set storage pointer based upon assigned id (by factory)\n\n    bytes32 constant ACCESS_STORAGE_POSITION = keccak256('diamond.standard.access.storage');\n\n    struct RoleStorage {\n        mapping(bytes32 => RoleData) roles;\n    }\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    function roleStorage() internal pure returns (RoleStorage storage rs) {\n        bytes32 position = ACCESS_STORAGE_POSITION;\n        assembly {\n            rs.slot := position\n        }\n    }\n}\n"
    },
    "contracts/TMP/TMP1/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    function grantRole(bytes32 role, address account) external;\n\n    function revokeRole(bytes32 role, address account) external;\n\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/TMP/TMP1/IAccessControlEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\ninterface IAccessControlEvents {\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n}\n"
    },
    "contracts/TMP/RelayReceiver.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\n// Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/GSN/GSNRecipient.sol\n// But kept minimalist.\ncontract RelayReceiver {\n    function _msgSender() internal pure returns (address payable result) {\n        // If not call from RelayHub, return original sender\n        // We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array\n        // is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing\n        // so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would\n        // require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20\n        // bytes. This can always be done due to the 32-byte prefix.\n\n        // The final memory read index is msg.data.length - 20 + 32 - 12 = msg.data.length. Using inline assembly is the\n        // easiest/most-efficient way to perform this operation.\n\n        // These fields are not accessible from assembly\n        bytes memory array = msg.data;\n        uint256 index = msg.data.length;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n            result := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/03-MemberAccess/MemberAccess.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* @title Member Access Control\n* @author Evert Kors <evert@thx.network>\n* @notice Manage access control for MEMBER, MANAGER and OWNER roles.\n* \n* Dependencies:\n* TMP-1 Access Control: https://github.com/thxprotocol/modules/issues/1\n* \n* Implementations: \n* TMP-2 Member ID: https://github.com/thxprotocol/modules/issues/2\n* TMP-3 Pool Roles: https://github.com/thxprotocol/modules/issues/3\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/utils/EnumerableSet.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\nimport '../01-AccessControl/AccessControl.sol';\n\n// depends on\nimport '../TMP/TMP1/IAccessControlEvents.sol';\nimport '../TMP/TMP1/LibAccessStorage.sol';\n\n// implements\nimport '../TMP/TMP2/IMemberID.sol';\nimport '../TMP/TMP2/LibMemberAccessStorage.sol';\nimport '../TMP/TMP3/IPoolRoles.sol';\n\nimport '../TMP/RelayReceiver.sol';\n\ncontract MemberAccess is IMemberID, IPoolRoles, RelayReceiver, IAccessControlEvents {\n    /**\n     * @param _owner Address of the account that should own the contract.\n     * @dev Should be called right after deploying the contract. _owner will become member, manager and role admin.\n     */\n    function initializeRoles(address _owner) external override {\n        require(LibMemberAccessStorage.memberStorage().memberCounter == 0, 'INIT');\n\n        LibMemberAccessStorage.memberStorage().memberCounter = 1000;\n        _setupRole(DEFAULT_ADMIN_ROLE, _owner);\n        _setupRole(MEMBER_ROLE, _owner);\n        _setupRole(MANAGER_ROLE, _owner);\n        setupMember(_owner);\n    }\n\n    /**\n     * @param _account Address of the account to check the member role for.\n     * @return if the given address bears the member role.\n     */\n    function isMember(address _account) external view override returns (bool) {\n        return _isMember(_account);\n    }\n\n    /**\n     * @param _account Address of the account to give the member role to.\n     */\n    function addMember(address _account) external override {\n        require(_hasRole(MANAGER_ROLE, _msgSender()) || _hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'ACCESS');\n        setupMember(_account);\n        _grantRole(MEMBER_ROLE, _account);\n    }\n\n    /**\n     * @param _account Address of the account to revoke the member role for.\n     */\n    function removeMember(address _account) external override {\n        require(_hasRole(MANAGER_ROLE, _msgSender()) || _hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'ACCESS');\n        _revokeRole(MEMBER_ROLE, _account);\n    }\n\n    /**\n     * @param _account Address of the account to check the manager role for.\n     * @return if the given address bears the manager role.\n     */\n    function isManager(address _account) external view override returns (bool) {\n        return _isManager(_account);\n    }\n\n    /**\n     * @param _account Address of the account to give the manager role to.\n     */\n    function addManager(address _account) external override {\n        require(_hasRole(MANAGER_ROLE, _msgSender()) || _hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'ACCESS');\n        setupMember(_account);\n        _grantRole(MANAGER_ROLE, _account);\n    }\n\n    /**\n     * @param _account Address of the account to revoke the manager role for.\n     */\n    function removeManager(address _account) external override {\n        require(_hasRole(MANAGER_ROLE, _msgSender()) || _hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'ACCESS');\n        require(_msgSender() != _account, 'OWN_ACCOUNT');\n        _revokeRole(MANAGER_ROLE, _account);\n    }\n\n    /**\n     * @param _account Address of the account to check the manager role admin account for.\n     * @return if the given address is the manager role admin.\n     */\n    function isManagerRoleAdmin(address _account) external view override returns (bool) {\n        return _hasRole(LibAccessStorage.roleStorage().roles[MANAGER_ROLE].adminRole, _account);\n    }\n\n    /**\n     * @param _account Address of the account to check the member role admin account for.\n     * @return if the given address is the member role admin.\n     */\n    function isMemberRoleAdmin(address _account) external view override returns (bool) {\n        return _hasRole(LibAccessStorage.roleStorage().roles[MEMBER_ROLE].adminRole, _account);\n    }\n\n    /**\n     * @return address of the contract owner.\n     */\n    function getOwner() external view override returns (address) {\n        return _getOwner();\n    }\n\n    /**\n     * @notice Upgrades an existing member address to a new member address, can only be called by the member itself.\n     * @param _oldAddress The current address of the member.\n     * @param _newAddress The new address of the member.\n     * @dev Different member id's can map to the same address.\n     */\n    function upgradeAddress(address _oldAddress, address _newAddress) external override {\n        require(_oldAddress == _msgSender(), 'OLD_NOT_SENDER');\n        LibMemberAccessStorage.MemberStorage storage ms = LibMemberAccessStorage.memberStorage();\n        uint256 member = ms.addressToMember[_oldAddress];\n        require(member != 0, 'NON_MEMBER');\n        ms.addressToMember[_oldAddress] = 0;\n        ms.addressToMember[_newAddress] = member;\n        ms.memberToAddress[member] = _newAddress;\n\n        if (_hasRole(MEMBER_ROLE, _oldAddress)) {\n            _revokeRole(MEMBER_ROLE, _oldAddress);\n            _grantRole(MEMBER_ROLE, _newAddress);\n        }\n\n        if (_hasRole(MANAGER_ROLE, _oldAddress)) {\n            _revokeRole(MANAGER_ROLE, _oldAddress);\n            _grantRole(MANAGER_ROLE, _newAddress);\n        }\n        emit MemberAddressChanged(member, _oldAddress, _newAddress);\n    }\n\n    /**\n     * @notice Upgrades an existing member address to a new member address, can only be called by the member itself.\n     * @param _member The index of the member account.\n     * @dev Different member id's can map to the same address.\n     * @return Address of the member for the given member index in the memberToAddress storage.\n     */\n    function getAddressByMember(uint256 _member) external view override returns (address) {\n        return LibMemberAccessStorage.memberStorage().memberToAddress[_member];\n    }\n\n    /**\n     * @param _address The address of the member account.\n     * @return Index of the member for a given address.\n     */\n    function getMemberByAddress(address _address) external view override returns (uint256) {\n        return LibMemberAccessStorage.memberStorage().addressToMember[_address];\n    }\n\n    /**\n     * @param _account Address of the member.\n     * @dev Called during initilization.\n     */\n    function setupMember(address _account) internal {\n        LibMemberAccessStorage.MemberStorage storage ms = LibMemberAccessStorage.memberStorage();\n        uint256 member = ms.addressToMember[_account];\n        if (member != 0) {\n            //member is already setup\n            return;\n        }\n        ms.memberCounter += 1;\n        ms.addressToMember[_account] = ms.memberCounter;\n        ms.memberToAddress[ms.memberCounter] = _account;\n    }\n\n    //\n    // Access control view methods internal\n    //\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    /**\n     * @dev Checks if account bears role.\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     * @return if role member storage array contains the given account address.\n     */\n    function _hasRole(bytes32 role, address account) internal view virtual returns (bool) {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        return rs.roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Called in initialize methods.\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Called during initialization\n     * @param role Bytes32 array representing the role.\n     * @param adminRole Address of the role admin\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        emit RoleAdminChanged(role, rs.roles[role].adminRole, adminRole);\n        rs.roles[role].adminRole = adminRole;\n    }\n\n    /**\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        if (rs.roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        if (rs.roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    //\n    // Pool roles view methods internal\n    //\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n    bytes32 internal constant MEMBER_ROLE = keccak256('MEMBER_ROLE');\n    bytes32 internal constant MANAGER_ROLE = keccak256('MANAGER_ROLE');\n\n    function _isManager(address _account) internal view returns (bool) {\n        return _hasRole(MANAGER_ROLE, _account);\n    }\n\n    function _isMember(address _account) internal view returns (bool) {\n        return _hasRole(MEMBER_ROLE, _account) || _hasRole(MANAGER_ROLE, _account);\n    }\n\n    function _getOwner() internal view returns (address) {\n        return LibDiamond.contractOwner();\n    }\n}\n"
    },
    "diamond-2/contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n*\n* This is gas optimized by reducing storage reads and storage writes.\n* This code is as complex as it is to reduce gas costs.\n/******************************************************************************/\n\nimport \"../interfaces/IDiamondCut.sol\";\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // owner of the contract\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n        _;\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        if (selectorCount % 8 > 0) {\n            // get last selectorSlot\n            selectorSlot = ds.selectorSlots[selectorCount / 8];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        if (selectorCount % 8 > 0) {\n            ds.selectorSlots[selectorCount / 8] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            require(_newFacetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n                // add facet for selector\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                uint256 selectorInSlotPosition = (_selectorCount % 8) * 32;\n                // clear selector position in slot and add selector\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    ds.selectorSlots[_selectorCount / 8] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            require(_newFacetAddress != address(0), \"LibDiamondCut: Replace facet can't be address(0)\");\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            uint256 selectorSlotCount = _selectorCount / 8;\n            uint256 selectorInSlotIndex = (_selectorCount % 8) - 1;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n                    // only useful if immutable functions exist\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex * 32));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    oldSelectorsSlotCount = oldSelectorCount / 8;\n                    oldSelectorInSlotPosition = (oldSelectorCount % 8) * 32;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n                selectorInSlotIndex--;\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex + 1;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"LibDiamondCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/TMP/TMP2/IMemberID.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\ninterface IMemberID {\n    event MemberAddressChanged(uint256 indexed memberID, address indexed previousAddress, address indexed newAddress);\n\n    function upgradeAddress(address _oldAddress, address _newAddress) external;\n\n    function getAddressByMember(uint256 _member) external view returns (address);\n\n    function getMemberByAddress(address _address) external view returns (uint256);\n}\n"
    },
    "contracts/TMP/TMP2/LibMemberAccessStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\nlibrary LibMemberAccessStorage {\n    bytes32 constant MEMBER_ACCESS_STORAGE_POSITION = keccak256('diamond.standard.member.access.storage');\n\n    struct MemberStorage {\n        uint256 memberCounter;\n        mapping(address => uint256) addressToMember;\n        mapping(uint256 => address) memberToAddress;\n    }\n\n    function memberStorage() internal pure returns (MemberStorage storage rs) {\n        bytes32 position = MEMBER_ACCESS_STORAGE_POSITION;\n        assembly {\n            rs.slot := position\n        }\n    }\n}\n"
    },
    "contracts/TMP/TMP3/IPoolRoles.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\ninterface IPoolRoles {\n    function initializeRoles(address _owner) external;\n\n    function isMember(address _account) external view returns (bool);\n\n    function addMember(address _account) external;\n\n    function removeMember(address _account) external;\n\n    function isManager(address _account) external view returns (bool);\n\n    function addManager(address _account) external;\n\n    function removeManager(address _account) external;\n\n    function isManagerRoleAdmin(address _account) external view returns (bool);\n\n    function isMemberRoleAdmin(address _account) external view returns (bool);\n\n    function getOwner() external view returns (address);\n}\n"
    },
    "diamond-2/contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/06-Reward/RewardPollProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Reward Poll Proxy\n* @author Evert Kors <evert@thx.network>\n* @notice Supports relayed reward poll calls.\n* \n* Implementations:\n* TMP-6 Base poll: https://github.com/thxprotocol/modules/issues/6\n* TMP-8 Rewards: https://github.com/thxprotocol/modules/issues/8\n/******************************************************************************/\n\nimport '../TMP/TMP8/IRewardPollProxy.sol';\nimport '../TMP/TMP6/LibBasePollStorage.sol';\n\nimport '../TMP/RelayReceiver.sol';\n\ncontract RewardPollProxy is IRewardPollProxy, RelayReceiver {\n    /**\n     * @dev This function signs the _rewardPollVote function + parameters and\n     * calls it on behalf of the original sender of the message.\n     * @param _id Tbe reward ID the poll is started for.\n     * @param _agree Boolean reflecting agreement with the poll.\n     */\n    function rewardPollVote(uint256 _id, bool _agree) external override {\n        // Get the storage position for the given reward poll _id\n        bytes32 position = LibBasePollStorage.getPosition(_id);\n        // Get the function signature\n        bytes4 sig = bytes4(keccak256('_rewardPollVote(bool)'));\n        // Encode the function call with the given _agree argument\n        bytes memory _call = abi.encodeWithSelector(sig, _agree);\n        // Call the function on behalf of the original sender of the message.\n        (bool success, bytes memory data) = address(this).call(abi.encodePacked(_call, position, _msgSender()));\n        require(success, string(data));\n    }\n\n    function rewardPollRevokeVote(uint256 _id) external override {\n        bytes32 position = LibBasePollStorage.getPosition(_id);\n        bytes4 sig = bytes4(keccak256('_rewardPollRevokeVote()'));\n        bytes memory _call = abi.encodeWithSelector(sig);\n\n        (bool success, bytes memory data) = address(this).call(abi.encodePacked(_call, position, _msgSender()));\n        require(success, string(data));\n    }\n\n    function rewardPollFinalize(uint256 _id) external override {\n        bytes32 position = LibBasePollStorage.getPosition(_id);\n        bytes4 sig = bytes4(keccak256('_rewardPollFinalize()'));\n        bytes memory _call = abi.encodeWithSelector(sig);\n\n        (bool success, bytes memory data) = address(this).call(abi.encodePacked(_call, position, _msgSender()));\n        require(success, string(data));\n    }\n\n    function rewardPollApprovalState(uint256 _id) external view override returns (bool) {\n        bytes32 position = LibBasePollStorage.getPosition(_id);\n        bytes4 sig = bytes4(keccak256('_rewardPollApprovalState()'));\n        bytes memory _call = abi.encodeWithSelector(sig);\n\n        (bool success, bytes memory data) = address(this).staticcall(abi.encodePacked(_call, position, _msgSender()));\n        require(success, string(data));\n        return abi.decode(data, (bool));\n    }\n}\n"
    },
    "contracts/TMP/TMP8/IRewardPollProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\ninterface IRewardPollProxy {\n    function rewardPollVote(uint256 _id, bool _agree) external;\n\n    function rewardPollRevokeVote(uint256 _id) external;\n\n    function rewardPollFinalize(uint256 _id) external;\n\n    function rewardPollApprovalState(uint256 _id) external view returns (bool);\n}\n"
    },
    "contracts/TMP/TMP6/LibBasePollStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\n/// @dev This Lib is used to create unique storage pointers and store structured data in them.\nlibrary LibBasePollStorage {\n    bytes32 constant BASE_STORAGE = keccak256('diamond.contract.assetpool.basepoll');\n\n    /**\n     * @dev Stores the amount of polls created in the diamond.\n     */\n    struct BaseStorage {\n        uint256 pollCounter;\n    }\n\n    /**\n     * @dev Stores the information of a poll for a given storage pointer.\n     */\n    struct BasePollStorage {\n        uint256 id;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 yesCounter;\n        uint256 noCounter;\n        uint256 totalVoted;\n        mapping(address => Vote) votesByAddress;\n    }\n    /**\n     * @dev Stores a vote for a poll in BasePollStorage.votesByAddress.\n     */\n    struct Vote {\n        uint256 time;\n        uint256 weight;\n        bool agree;\n    }\n\n    /**\n     * @param _id The ID of a poll.\n     * @return storage position for a given poll id\n     */\n    function getPosition(uint256 _id) internal pure returns (bytes32) {\n        return keccak256(abi.encode('diamond.contract.assetpool.basepoll', _id));\n    }\n\n    /**\n     * @return bs The base storage containing pollCounter of all polls.\n     */\n    function baseStorage() internal pure returns (BaseStorage storage bs) {\n        bytes32 position = BASE_STORAGE;\n        assembly {\n            bs.slot := position\n        }\n    }\n\n    /**\n     * @param _pos The storage position of the poll.\n     * @return bs The BasePollStorage struct storage for a poll its storage position.\n     */\n    function basePollStorage(bytes32 _pos) internal pure returns (BasePollStorage storage bs) {\n        assembly {\n            bs.slot := _pos\n        }\n    }\n\n    /**\n     * @param _id The poll id\n     * @return bs The BasePollStorage struct storage for a given poll ID.\n     */\n    function basePollStorageId(uint256 _id) internal pure returns (BasePollStorage storage bs) {\n        bytes32 position = getPosition(_id);\n        assembly {\n            bs.slot := position\n        }\n    }\n}\n"
    },
    "contracts/10-RewardBypass/RewardByPollProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Rewards (Bypass poll)\n* @author Evert Kors <evert@thx.network>\n* @dev Inherits default reward poll proxy\n* \n* Implementations: \n* TMP-8 Rewards: https://github.com/thxprotocol/modules/issues/7\n/******************************************************************************/\n\nimport '../06-Reward/RewardPollProxy.sol';\n\ncontract RewardByPollProxy is RewardPollProxy {}\n"
    },
    "contracts/TMP/TMP6/IBasePoll.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\nimport './LibBasePollStorage.sol';\n\ninterface IBasePoll {\n    function getStartTime(uint256 _id) external view returns (uint256);\n\n    function getEndTime(uint256 _id) external view returns (uint256);\n\n    function getYesCounter(uint256 _id) external view returns (uint256);\n\n    function getNoCounter(uint256 _id) external view returns (uint256);\n\n    function getTotalVoted(uint256 _id) external view returns (uint256);\n\n    function getVoteByAddress(uint256 _id, address _address) external view returns (LibBasePollStorage.Vote memory);\n}\n"
    },
    "contracts/IDefaultDiamond.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\nimport 'diamond-2/contracts/interfaces/IERC173.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondLoupe.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondCut.sol';\nimport './TMP/TMP1/IAccessControl.sol';\nimport './TMP/TMP1/IAccessControlEvents.sol';\nimport './TMP/TMP2/IMemberID.sol';\nimport './TMP/TMP3/IPoolRoles.sol';\nimport './TMP/TMP5/IToken.sol';\nimport './TMP/TMP6/IBasePoll.sol';\nimport './TMP/TMP7/IWithdraw.sol';\nimport './TMP/TMP7/IWithdrawPoll.sol';\nimport './TMP/TMP7/IWithdrawPollProxy.sol';\nimport './TMP/TMP8/IReward.sol';\nimport './TMP/TMP8/IRewardPoll.sol';\nimport './TMP/TMP8/IRewardPollProxy.sol';\nimport './TMP/TMP9/IRelayHub.sol';\n\ninterface IDefaultDiamond is\n    IERC173,\n    IDiamondLoupe,\n    IDiamondCut,\n    IAccessControl,\n    IAccessControlEvents,\n    IMemberID,\n    IPoolRoles,\n    IToken,\n    IBasePoll,\n    IWithdraw,\n    IWithdrawPoll,\n    IWithdrawPollProxy,\n    IReward,\n    IRewardPoll,\n    IRewardPollProxy,\n    IRelayHub\n{\n    function setupMockAccess(bytes32[] memory roles, address[] memory addr) external;\n}\n"
    },
    "diamond-2/contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "diamond-2/contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/TMP/TMP5/IToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\ninterface IToken {\n    event TokenUpdated(address old, address current);\n    event RegistryUpdated(address old, address current);\n    event DepositFeeCollected(uint256 fee);\n    event Depositted(address sender, uint256 amount);\n\n    function getBalance() external view returns (uint256);\n\n    function deposit(uint256 _amount) external;\n\n    function setPoolRegistry(address _registry) external;\n\n    function getPoolRegistry() external view returns (address);\n\n    function addToken(address _token) external;\n\n    function getToken() external view returns (address);\n}\n"
    },
    "contracts/TMP/TMP7/IWithdraw.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\ninterface IWithdraw {\n    event WithdrawPollCreated(uint256 id, uint256 indexed member);\n\n    function proposeWithdraw(uint256 _amount, address _beneficiary, uint256 _unlockDate) external;\n\n    function proposeBulkWithdraw(uint256[] memory _amounts, address[] memory _beneficiaries, uint256 _unlockDate) external;\n\n    function setProposeWithdrawPollDuration(uint256 _duration) external;\n\n    function getProposeWithdrawPollDuration() external view returns (uint256);\n}\n"
    },
    "contracts/TMP/TMP7/IWithdrawPoll.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\ninterface IWithdrawPoll {\n    event Withdrawn(uint256 id, address indexed member, uint256 reward);\n    event WithdrawPollVoted(uint256 id, address indexed member, bool vote);\n    event WithdrawPollFinalized(uint256 id, bool approved);\n    event WithdrawPollRevokedVote(uint256 id, address indexed member);\n    event WithdrawFeeCollected(uint256 fee);\n\n    function getBeneficiary(uint256 _id) external view returns (uint256);\n\n    function getAmount(uint256 _id) external view returns (uint256);\n\n    function getUnlockDate(uint256 _id) external view returns (uint256);\n\n    function _withdrawPollVote(bool _agree) external;\n\n    function _withdrawPollRevokeVote() external;\n\n    function _withdrawPollFinalize() external;\n\n    function _withdrawPollApprovalState() external view returns (bool);\n}\n"
    },
    "contracts/TMP/TMP7/IWithdrawPollProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\ninterface IWithdrawPollProxy {\n    function withdrawPollVote(uint256 _id, bool _agree) external;\n\n    function withdrawPollRevokeVote(uint256 _id) external;\n\n    function withdrawPollFinalize(uint256 _id) external;\n\n    function withdrawPollApprovalState(uint256 _id) external view returns (bool);\n}\n"
    },
    "contracts/TMP/TMP8/IReward.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\nimport './LibRewardPollStorage.sol';\n\ninterface IReward {\n    event RewardPollCreated(uint256 id, address indexed member, uint256 rewardID, uint256 proposal);\n\n    function setRewardPollDuration(uint256 _duration) external;\n\n    function getRewardPollDuration() external view returns (uint256);\n\n    function addReward(uint256 _withdrawAmount, uint256 _withdrawDuration) external;\n\n    function getReward(uint256 _id) external view returns (LibRewardPollStorage.Reward memory);\n\n    function updateReward(\n        uint256 _id,\n        uint256 _withdrawAmount,\n        uint256 _withdrawDuration\n    ) external;\n\n    function enableReward(uint256 _id) external;\n\n    function disableReward(uint256 _id) external;\n\n    function claimRewardFor(uint256 _id, address _beneficiary) external;\n\n    function claimReward(uint256 _id) external;\n}\n"
    },
    "contracts/TMP/TMP8/IRewardPoll.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\ninterface IRewardPoll {\n    event RewardPollDisabled(uint256 id);\n    event RewardPollEnabled(uint256 id);\n    event RewardPollUpdated(uint256 id, uint256 amount, uint256 duration);\n    event RewardPollVoted(uint256 id, address indexed member, bool vote);\n    event RewardPollFinalized(uint256 id, bool approved);\n    event RewardPollRevokedVote(uint256 id, address indexed member);\n\n    function getWithdrawAmount(uint256 _id) external view returns (uint256);\n\n    function getWithdrawDuration(uint256 _id) external view returns (uint256);\n\n    function getRewardIndex(uint256 _id) external view returns (uint256);\n\n    function _rewardPollVote(bool _agree) external;\n\n    function _rewardPollRevokeVote() external;\n\n    function _rewardPollFinalize() external;\n\n    function _rewardPollApprovalState() external view returns (bool);\n}\n"
    },
    "contracts/TMP/TMP9/IRelayHub.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\ninterface IRelayHub {\n    event Result(bool success, bytes data);\n\n    function getLatestNonce(address _signer) external view returns (uint256);\n\n    function call(\n        bytes calldata _call,\n        uint256 _nonce,\n        bytes memory _sig\n    ) external;\n}\n"
    },
    "contracts/TMP/TMP8/LibRewardPollStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\nlibrary LibRewardPollStorage {\n    bytes32 constant REWARD_STORAGE = keccak256('diamond.contract.assetpool.rewardpoll');\n\n    struct RewardStorage {\n        uint256 rewardPollDuration;\n        Reward[] rewards;\n    }\n\n    enum RewardState { Disabled, Enabled }\n\n    struct Reward {\n        uint256 id;\n        uint256 withdrawAmount;\n        uint256 withdrawDuration;\n        uint256 pollId;\n        RewardState state;\n    }\n\n    function rewardStorage() internal pure returns (RewardStorage storage rs) {\n        bytes32 position = REWARD_STORAGE;\n        assembly {\n            rs.slot := position\n        }\n    }\n\n    struct RewardPollStorage {\n        uint256 rewardIndex;\n        uint256 withdrawAmount;\n        uint256 withdrawDuration;\n    }\n\n    function getPosition(uint256 _id) internal pure returns (bytes32) {\n        return keccak256(abi.encode('diamond.contract.assetpool.rewardpoll', _id));\n    }\n\n    function rewardPollStorage(bytes32 _pos) internal pure returns (RewardPollStorage storage rs) {\n        assembly {\n            rs.slot := _pos\n        }\n    }\n\n    function rewardPollStorageId(uint256 _id) internal pure returns (RewardPollStorage storage rs) {\n        bytes32 position = getPosition(_id);\n        assembly {\n            rs.slot := position\n        }\n    }\n}\n"
    },
    "contracts/07-RelayHub/RelayHub.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* @title RelayHub\n* @author Evert Kors <evert@thx.network>\n* @notice Manage gas costs for relayed contract calls.\n* \n* Implementations:\n* TMP-9 Gas Station: https://github.com/thxprotocol/modules/issues/9\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/cryptography/ECDSA.sol';\nimport '../TMP/TMP9/LibRelayHubStorage.sol';\nimport '../TMP/TMP9/IRelayHub.sol';\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\ncontract RelayHubFacet is IRelayHub {\n    /**\n     * @dev Get the latest nonce of a given signer\n     * @param _signer Address of the signer\n     */\n    function getLatestNonce(address _signer) external view override returns (uint256) {\n        return LibRelayHubStorage.rhStorage().signerNonce[_signer];\n    }\n\n    /**\n     * @dev Validate a given nonce, reverts if nonce is not right\n     * @param _signer Address of the signer\n     * @param _nonce Nonce of the signer\n     */\n    function validateNonce(address _signer, uint256 _nonce) private {\n        LibRelayHubStorage.RHStorage storage s = LibRelayHubStorage.rhStorage();\n\n        require(s.signerNonce[_signer] + 1 == _nonce, 'INVALID_NONCE');\n        s.signerNonce[_signer] = _nonce;\n    }\n\n    // Multinonce? https://github.com/PISAresearch/metamask-comp#multinonce\n    /**\n     * @param _call Encoded function + arguments data\n     * @param _nonce Latest nonce for the original sender\n     * @param _sig Signed message\n     */\n    function call(\n        bytes memory _call,\n        uint256 _nonce,\n        bytes memory _sig\n    ) external override {\n        bytes32 message = ECDSA.toEthSignedMessageHash(keccak256(abi.encodePacked(_call, _nonce)));\n        address signer = ECDSA.recover(message, _sig);\n\n        validateNonce(signer, _nonce);\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(_call, signer));\n        emit Result(success, returnData);\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/TMP/TMP9/LibRelayHubStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\nlibrary LibRelayHubStorage {\n    bytes32 constant RELAYHUB_STORAGE_POSITION = keccak256('diamond.standard.relayhub.storage');\n\n    struct RHStorage {\n        address admin;\n        mapping(address => uint256) signerNonce;\n        uint256 lockCounter;\n        bool enabled;\n    }\n\n    function rhStorage() internal pure returns (RHStorage storage bs) {\n        bytes32 position = RELAYHUB_STORAGE_POSITION;\n        assembly {\n            bs.slot := position\n        }\n    }\n}\n"
    },
    "contracts/TokenFactory/TokenFactoryFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport '../util/ERC20/LimitedSupplyToken.sol';\nimport '../util/ERC20/UnlimitedSupplyToken.sol';\nimport '../util/ERC721/NonFungibleToken.sol';\nimport './ITokenFactory.sol';\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\ncontract TokenFactoryFacet is ITokenFactory {\n    /**\n     * @param _name string Token name.\n     * @param _symbol string Token symbol.\n     * @param _to address Address the total supply will be minted to.\n     */\n    function deployNonFungibleToken(\n        string memory _name,\n        string memory _symbol,\n        address _to,\n        string memory _baseURI\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n\n        NonFungibleToken t = new NonFungibleToken(_name, _symbol, _to, _baseURI);\n        emit TokenDeployed(address(t), TokenType.NonFungible);\n    }\n\n    /**\n     * @param _name string Token name.\n     * @param _symbol string Token symbol.\n     * @param to address Address the total supply will be minted to.\n     * @param amount uint256 Total supply of this token.\n     */\n    function deployLimitedSupplyToken(\n        string memory _name,\n        string memory _symbol,\n        address to,\n        uint256 amount\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n\n        LimitedSupplyToken t = new LimitedSupplyToken(_name, _symbol, to, amount);\n        emit TokenDeployed(address(t), TokenType.Limited);\n    }\n\n    /**\n     * @param _name string Token name.\n     * @param _symbol string Token symbol.\n     * @param _minters address[] List if address that able to mint new tokens\n     * @param _admin address Addres which is allowed to transfer tokens which are minted on the fly.\n     */\n    function deployUnlimitedSupplyToken(\n        string memory _name,\n        string memory _symbol,\n        address[] memory _minters,\n        address _admin\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n\n        UnlimitedSupplyToken t = new UnlimitedSupplyToken(_name, _symbol, _minters, _admin);\n        emit TokenDeployed(address(t), TokenType.Unlimited);\n    }\n}\n"
    },
    "contracts/util/ERC20/LimitedSupplyToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* @title ERC20 Limited Supply\n* @author Peter Polman <peter@thx.network>\n* @notice Used for point systems with a limited supply. Mints the full supply to the to argument given in the contructor. \n* @dev Not upgradable contract.\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract LimitedSupplyToken is ERC20 {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address to,\n        uint256 amount\n    ) ERC20(_name, _symbol) {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/util/ERC20/UnlimitedSupplyToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* @title ERC20 Unlimited Supply\n* @author Evert Kors <evert@thx.network>\n* @notice Used for point systems with an unlimited supply. Mints the required tokens whenever they are needed.\n* @dev Not upgradable contract.\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract UnlimitedSupplyToken is ERC20 {\n    address public immutable admin;\n    mapping(address => bool) public minters;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        address[] memory _minters,\n        address _admin\n    ) ERC20(_name, _symbol) {\n        require(_admin != address(0), 'INVALID_ADDRESS');\n        admin = _admin;\n\n        for (uint256 i = 0; i < _minters.length; ++i) {\n            require(_minters[i] != address(0), 'NOT_MINTER');\n            minters[_minters[i]] = true;\n        }\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, 'ADMIN_ONLY');\n        _;\n    }\n\n    /**\n     * Add a new minter to this contract\n     * @param _minter Minter address to add.\n     */\n    function addMinter(address _minter) public onlyAdmin {\n        require(_minter != address(0), 'INVALID_ADDRESS');\n        minters[_minter] = true;\n    }\n\n    /**\n     * Remove a minter from this contract\n     * @param _minter Minter address to remove.\n     */\n    function removeMinter(address _minter) public onlyAdmin {\n        require(_minter != address(0), 'INVALID_ADDRESS');\n        require(minters[_minter] == true, 'NOT_MINTER');\n\n        delete minters[_minter];\n    }\n\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal override {\n        if (minters[_from] == true) {\n            _mint(_from, _amount);\n        }\n    }\n}\n"
    },
    "contracts/util/ERC721/NonFungibleToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* @title ERC721 URI Storage\n* @author Peter Polman <peter@thx.network>\n* @notice Used for point systems with a limited supply. Mints the full supply to the to argument given in the contructor. \n* @dev Not upgradable contract.\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/utils/Counters.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract NonFungibleToken is ERC721, Ownable {\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIds;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address owner_,\n        string memory baseURI_\n    ) ERC721(name_, symbol_) {\n        transferOwnership(owner_);\n        _setBaseURI(baseURI_);\n    }\n\n    function mint(address recipient, string memory tokenURI) external onlyOwner returns (uint256) {\n        _tokenIds.increment();\n\n        uint256 newItemId = _tokenIds.current();\n        _mint(recipient, newItemId);\n        _setTokenURI(newItemId, tokenURI);\n\n        return newItemId;\n    }\n}\n"
    },
    "contracts/TokenFactory/ITokenFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\ninterface ITokenFactory {\n    enum TokenType { Limited, Unlimited, NonFungible }\n    event TokenDeployed(address token, TokenType tokenType);\n\n    function deployNonFungibleToken(\n        string memory _name,\n        string memory _symbol,\n        address _to,\n        string memory _baseURI\n    ) external;\n\n    function deployLimitedSupplyToken(\n        string memory _name,\n        string memory _symbol,\n        address to,\n        uint256 amount\n    ) external;\n\n    function deployUnlimitedSupplyToken(\n        string memory _name,\n        string memory _symbol,\n        address[] memory _minters,\n        address _admin\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"./IERC721Enumerable.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"../../introspection/ERC165.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/EnumerableSet.sol\";\nimport \"../../utils/EnumerableMap.sol\";\nimport \"../../utils/Strings.sol\";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\n    using SafeMath for uint256;\n    using Address for address;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\n    using Strings for uint256;\n\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from holder address to their (enumerable) set of owned tokens\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n\n    // Enumerable mapping from token ids to their owners\n    EnumerableMap.UintToAddressMap private _tokenOwners;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping (uint256 => string) private _tokenURIs;\n\n    // Base URI\n    string private _baseURI;\n\n    /*\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n     *\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n\n    /*\n     *     bytes4(keccak256('name()')) == 0x06fdde03\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n     *\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n\n    /*\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n     *\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n\n        return _holderTokens[owner].length();\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n\n        // If there is no base URI, return the token URI.\n        if (bytes(_baseURI).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(_baseURI, _tokenURI));\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(_baseURI, tokenId.toString()));\n    }\n\n    /**\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\n    * to the token ID if no specific URI is set for that token ID.\n    */\n    function baseURI() public view returns (string memory) {\n        return _baseURI;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n        return _holderTokens[owner].at(index);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n        return _tokenOwners.length();\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view override returns (uint256) {\n        (uint256 tokenId, ) = _tokenOwners.at(index);\n        return tokenId;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _tokenOwners.contains(tokenId);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     d*\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n\n        _holderTokens[owner].remove(tokenId);\n\n        _tokenOwners.remove(tokenId);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _holderTokens[from].remove(tokenId);\n        _holderTokens[to].add(tokenId);\n\n        _tokenOwners.set(tokenId, to);\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Internal function to set the base URI for all token IDs. It is\n     * automatically added as a prefix to the value returned in {tokenURI},\n     * or to the token ID if {tokenURI} is empty.\n     */\n    function _setBaseURI(string memory baseURI_) internal virtual {\n        _baseURI = baseURI_;\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n            IERC721Receiver(to).onERC721Received.selector,\n            _msgSender(),\n            from,\n            tokenId,\n            _data\n        ), \"ERC721: transfer to non ERC721Receiver implementer\");\n        bytes4 retval = abi.decode(returndata, (bytes4));\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    function _approve(address to, uint256 tokenId) private {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../math/SafeMath.sol\";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the {SafeMath}\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"../../introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165 is IERC165 {\n    /*\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n     */\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    constructor () internal {\n        // Derived contracts need only register support for their own interfaces,\n        // we register support for ERC165 itself here\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     *\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct MapEntry {\n        bytes32 _key;\n        bytes32 _value;\n    }\n\n    struct Map {\n        // Storage of map keys and values\n        MapEntry[] _entries;\n\n        // Position of the entry defined by a key in the `entries` array, plus 1\n        // because index 0 means a key is not in the map.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\n            map._entries.push(MapEntry({ _key: key, _value: value }));\n            // The entry is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            map._indexes[key] = map._entries.length;\n            return true;\n        } else {\n            map._entries[keyIndex - 1]._value = value;\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        // We read and store the key's index to prevent multiple reads from the same storage slot\n        uint256 keyIndex = map._indexes[key];\n\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = keyIndex - 1;\n            uint256 lastIndex = map._entries.length - 1;\n\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            MapEntry storage lastEntry = map._entries[lastIndex];\n\n            // Move the last entry to the index where the entry to delete is\n            map._entries[toDeleteIndex] = lastEntry;\n            // Update the index for the moved entry\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved entry was stored\n            map._entries.pop();\n\n            // Delete the index for the deleted slot\n            delete map._indexes[key];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._indexes[key] != 0;\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._entries.length;\n    }\n\n   /**\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n    *\n    * Note that there are no guarantees on the ordering of entries inside the\n    * array, and it may change when more entries are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n        MapEntry storage entry = map._entries[index];\n        return (entry._key, entry._value);\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        return _get(map, key, \"EnumerableMap: nonexistent key\");\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     */\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\n        uint256 keyIndex = map._indexes[key];\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return _set(map._inner, bytes32(key), bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return _remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return _contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n   /**\n    * @dev Returns the element stored at position `index` in the set. O(1).\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (uint256(key), address(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint256(_get(map._inner, bytes32(key))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\n        return address(uint256(_get(map._inner, bytes32(key), errorMessage)));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        uint256 index = digits - 1;\n        temp = value;\n        while (temp != 0) {\n            buffer[index--] = byte(uint8(48 + temp % 10));\n            temp /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/TokenFactory/IDefaultTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\nimport 'diamond-2/contracts/interfaces/IERC173.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondLoupe.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondCut.sol';\nimport './ITokenFactory.sol';\n\ninterface IDefaultTokenFactory is IERC173, IDiamondLoupe, IDiamondCut, ITokenFactory {}\n"
    },
    "contracts/PoolRegistry/LibPoolRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondCut.sol';\n\nlibrary LibPoolRegistryStorage {\n    bytes32 constant STORAGE_POSITION = keccak256('diamond.standard.poolregistry.storage');\n\n    struct Data {\n        address feeCollector;\n        uint256 feePercentage;\n    }\n\n    function s() internal pure returns (Data storage bs) {\n        bytes32 position = STORAGE_POSITION;\n        assembly {\n            bs.slot := position\n        }\n    }\n}\n"
    },
    "contracts/PoolRegistry/PoolRegistryFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport './IPoolRegistry.sol';\nimport './LibPoolRegistryStorage.sol';\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\ncontract PoolRegistryFacet is IPoolRegistry {\n    /**\n     * @param _feeCollector Address of the FeeCollector contract.\n     * @param _feePercentage Integer representing the deposit fee percentage.\n     */\n    function initialize(address _feeCollector, uint256 _feePercentage) external override {\n        LibDiamond.enforceIsContractOwner();\n\n        LibPoolRegistryStorage.Data storage s = LibPoolRegistryStorage.s();\n        s.feeCollector = _feeCollector;\n        s.feePercentage = _feePercentage;\n    }\n\n    /**\n     * @param _feeCollector Address of the FeeCollector contract.\n     */\n    function setFeeCollector(address _feeCollector) external override {\n        LibDiamond.enforceIsContractOwner();\n\n        LibPoolRegistryStorage.Data storage s = LibPoolRegistryStorage.s();\n        s.feeCollector = _feeCollector;\n    }\n\n    /**\n     * @param _feePercentage 0 - 10**18 value used for substracting fees from deposits into an asset pool.\n     */\n    function setFeePercentage(uint256 _feePercentage) external override {\n        LibDiamond.enforceIsContractOwner();\n\n        LibPoolRegistryStorage.Data storage s = LibPoolRegistryStorage.s();\n        s.feePercentage = _feePercentage;\n    }\n\n    function feeCollector() external view override returns (address) {\n        return LibPoolRegistryStorage.s().feeCollector;\n    }\n\n    function feePercentage() external view override returns (uint256) {\n        return LibPoolRegistryStorage.s().feePercentage;\n    }\n}\n"
    },
    "contracts/PoolRegistry/IPoolRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.1;\n\ninterface IPoolRegistry {\n    function initialize(address _feeCollector, uint256 _feePercentage) external;\n\n    function setFeeCollector(address _feeCollector) external;\n\n    function setFeePercentage(uint256 _feePercentage) external;\n\n    function feeCollector() external view returns (address);\n\n    function feePercentage() external view returns (uint256);\n}\n"
    },
    "contracts/PoolRegistry/IDefaultPoolRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\nimport 'diamond-2/contracts/interfaces/IERC173.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondLoupe.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondCut.sol';\nimport './IPoolRegistry.sol';\n\ninterface IDefaultPoolRegistry is IERC173, IDiamondLoupe, IDiamondCut, IPoolRegistry {}\n"
    },
    "diamond-2/contracts/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\r\n*\r\n* Implementation of a diamond.\r\n/******************************************************************************/\r\n\r\nimport \"./libraries/LibDiamond.sol\";\r\nimport \"./interfaces/IDiamondLoupe.sol\";\r\nimport \"./interfaces/IDiamondCut.sol\";\r\nimport \"./interfaces/IERC173.sol\";\r\nimport \"./interfaces/IERC165.sol\";\r\n\r\ncontract Diamond {\r\n    // more arguments are added to this struct\r\n    // this avoids stack too deep errors\r\n    struct DiamondArgs {\r\n        address owner;\r\n    }\r\n\r\n    constructor(IDiamondCut.FacetCut[] memory _diamondCut, DiamondArgs memory _args) payable {\r\n        LibDiamond.diamondCut(_diamondCut, address(0), new bytes(0));\r\n        LibDiamond.setContractOwner(_args.owner);\r\n\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n\r\n        // adding ERC165 data\r\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\r\n    }\r\n\r\n    // Find facet for function that is called and execute the\r\n    // function if a facet is found and return any value.\r\n    fallback() external payable {\r\n        LibDiamond.DiamondStorage storage ds;\r\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n        address facet = address(bytes20(ds.facets[msg.sig]));\r\n        require(facet != address(0), \"Diamond: Function does not exist\");\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n                case 0 {\r\n                    revert(0, returndatasize())\r\n                }\r\n                default {\r\n                    return(0, returndatasize())\r\n                }\r\n        }\r\n    }    \r\n}\r\n"
    },
    "diamond-2/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "diamond-2/contracts/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.1;\r\npragma experimental ABIEncoderV2;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\nimport \"../libraries/LibDiamond.sol\";\r\nimport \"../interfaces/IDiamondLoupe.sol\";\r\nimport \"../interfaces/IERC165.sol\";\r\n\r\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\r\n    // Diamond Loupe Functions\r\n    ////////////////////////////////////////////////////////////////////\r\n    /// These functions are expected to be called frequently by tools.\r\n    //\r\n    // struct Facet {\r\n    //     address facetAddress;\r\n    //     bytes4[] functionSelectors;\r\n    // }\r\n    /// @notice Gets all facets and their selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external override view returns (Facet[] memory facets_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facets_ = new Facet[](ds.selectorCount);\r\n        uint8[] memory numFacetSelectors = new uint8[](ds.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex * 32));\r\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\r\n                bool continueLoop = false;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\r\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\r\n                        // probably will never have more than 256 functions from one facet contract\r\n                        require(numFacetSelectors[facetIndex] < 255);\r\n                        numFacetSelectors[facetIndex]++;\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {\r\n                    continueLoop = false;\r\n                    continue;\r\n                }\r\n                facets_[numFacets].facetAddress = facetAddress_;\r\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\r\n                facets_[numFacets].functionSelectors[0] = selector;\r\n                numFacetSelectors[numFacets] = 1;\r\n                numFacets++;\r\n            }\r\n        }\r\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n            uint256 numSelectors = numFacetSelectors[facetIndex];\r\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\r\n            // setting the number of selectors\r\n            assembly {\r\n                mstore(selectors, numSelectors)\r\n            }\r\n        }\r\n        // setting the number of facets\r\n        assembly {\r\n            mstore(facets_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\r\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        uint256 numSelectors;\r\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex * 32));\r\n                address facet = address(bytes20(ds.facets[selector]));\r\n                if (_facet == facet) {\r\n                    _facetFunctionSelectors[numSelectors] = selector;\r\n                    numSelectors++;\r\n                }\r\n            }\r\n        }\r\n        // Set the number of selectors in the array\r\n        assembly {\r\n            mstore(_facetFunctionSelectors, numSelectors)\r\n        }\r\n    }\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddresses_ = new address[](ds.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex * 32));\r\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\r\n                bool continueLoop = false;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {\r\n                    continueLoop = false;\r\n                    continue;\r\n                }\r\n                facetAddresses_[numFacets] = facetAddress_;\r\n                numFacets++;\r\n            }\r\n        }\r\n        // Set the number of facet addresses in the array\r\n        assembly {\r\n            mstore(facetAddresses_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\r\n    }\r\n\r\n    // This implements ERC-165.\r\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        return ds.supportedInterfaces[_interfaceId];\r\n    }\r\n}\r\n"
    },
    "contracts/Import.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\nimport 'diamond-2/contracts/facets/DiamondCutFacet.sol';\nimport 'diamond-2/contracts/facets/DiamondLoupeFacet.sol';\nimport 'diamond-2/contracts/facets/OwnershipFacet.sol';\nimport 'diamond-2/contracts/Diamond.sol';\n\n// Get the compiler to pick up these facets\ncontract Imports {\n    DiamondCutFacet public diamondCutFacet;\n    DiamondLoupeFacet public diamondLoupeFacet;\n    OwnershipFacet public ownershipFacet;\n    Diamond public diamond;\n}\n"
    },
    "diamond-2/contracts/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"../libraries/LibDiamond.sol\";\n\ncontract DiamondCutFacet is IDiamondCut {    \n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        if (selectorCount % 8 > 0) {\n            // get last selectorSlot\n            selectorSlot = ds.selectorSlots[selectorCount / 8];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        if (selectorCount % 8 > 0) {\n            ds.selectorSlots[selectorCount / 8] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        LibDiamond.initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "diamond-2/contracts/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\n\nimport \"../libraries/LibDiamond.sol\";\nimport \"../interfaces/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    function owner() external override view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n}"
    },
    "contracts/AssetPoolFactory/IDefaultFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\nimport 'diamond-2/contracts/interfaces/IERC173.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondLoupe.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondCut.sol';\nimport './IAssetPoolFactory.sol';\n\ninterface IDefaultFactory is IERC173, IDiamondLoupe, IDiamondCut, IAssetPoolFactory {}\n"
    },
    "contracts/AssetPoolFactory/IAssetPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport 'diamond-2/contracts/interfaces/IDiamondCut.sol';\n\ninterface IAssetPoolFactory {\n    event AssetPoolDeployed(address assetPool);\n    event AssetPoolRegistered(address assetPool);\n\n    function setDefaultController(address _controller) external;\n\n    function registerAssetPool(address _pool) external;\n\n    function isAssetPool(address _pool) external view returns (bool);\n\n    function deployAssetPool(IDiamondCut.FacetCut[] memory _facets, address _registry) external;\n}\n"
    },
    "contracts/AssetPoolFactory/AssetPoolFactoryFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\nimport '../RelayDiamond.sol';\nimport '../IDefaultDiamond.sol';\nimport './IAssetPoolFactory.sol';\nimport './LibFactoryStorage.sol';\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\ncontract AssetPoolFactoryFacet is IAssetPoolFactory {\n    /**\n     * @notice Sets the controller for the factory diamond.\n     * @param _controller Address of the diamond controller.\n     */\n    function setDefaultController(address _controller) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibFactoryStorage.s().defaultController = _controller;\n    }\n\n    /**\n     * @notice Registers a pool address in the internal register. Only accessible for diamond owner.\n     * @param _pool Address of pool that should be registered.\n     */\n    function registerAssetPool(address _pool) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibFactoryStorage.Data storage s = LibFactoryStorage.s();\n        s.assetPools.push(_pool);\n        s.isAssetPool[_pool] = true;\n        emit AssetPoolRegistered(_pool);\n    }\n\n    function isAssetPool(address _pool) external view override returns (bool) {\n        LibFactoryStorage.Data storage s = LibFactoryStorage.s();\n        return s.isAssetPool[_pool];\n    }\n\n    /**\n     * @notice Deploys and stores the reference to an asset pool based on the current defaultCut.\n     * @dev Transfers ownership to the controller and initializes access control.\n     * @param _facets Asset Pool facets for the factory diamond to deploy.\n     * @param _registry Registry address to point the pool to.\n     */\n    function deployAssetPool(IDiamondCut.FacetCut[] memory _facets, address _registry) external override {\n        require(_registry != address(0), 'NO_REGISTRY');\n        LibDiamond.enforceIsContractOwner();\n        LibFactoryStorage.Data storage s = LibFactoryStorage.s();\n        //direct is required for the initialize functions below\n        RelayDiamond d = new RelayDiamond(_facets, address(this));\n        IDefaultDiamond assetPool = IDefaultDiamond(address(d));\n\n        assetPool.setPoolRegistry(_registry);\n        assetPool.transferOwnership(s.defaultController);\n        assetPool.initializeRoles(s.defaultController);\n\n        s.assetPools.push(address(d));\n        s.isAssetPool[address(d)] = true;\n        emit AssetPoolDeployed(address(d));\n    }\n}\n"
    },
    "contracts/RelayDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.1;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondLoupe.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondCut.sol';\nimport 'diamond-2/contracts/interfaces/IERC173.sol';\nimport 'diamond-2/contracts/interfaces/IERC165.sol';\n\ncontract RelayDiamond {\n    constructor(IDiamondCut.FacetCut[] memory _diamondCut, address _owner) payable {\n        LibDiamond.diamondCut(_diamondCut, address(0), new bytes(0));\n        LibDiamond.setContractOwner(_owner);\n\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\n        // adding ERC165 data\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n        address facet = address(bytes20(ds.facets[msg.sig]));\n\n        require(facet != address(0), 'Diamond: Function does not exist');\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            if eq(caller(), address()) {\n                let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n                switch result\n                    case 0 {\n                        revert(0, returndatasize())\n                    }\n                    default {\n                        return(0, returndatasize())\n                    }\n            }\n            {\n                mstore(calldatasize(), caller())\n                let result := delegatecall(gas(), facet, 0, add(calldatasize(), 0x20), 0, 0)\n                returndatacopy(0, 0, returndatasize())\n                switch result\n                    case 0 {\n                        revert(0, returndatasize())\n                    }\n                    default {\n                        return(0, returndatasize())\n                    }\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/AssetPoolFactory/LibFactoryStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport 'diamond-2/contracts/interfaces/IDiamondCut.sol';\n\nlibrary LibFactoryStorage {\n    bytes32 constant FACTORY_STORAGE_POSITION = keccak256('diamond.standard.poolfactory.storage');\n\n    struct Data {\n        address defaultController;\n        address[] assetPools;\n        mapping(address => bool) isAssetPool;\n        IDiamondCut.FacetCut[] defaultCut;\n    }\n\n    function s() internal pure returns (Data storage bs) {\n        bytes32 position = FACTORY_STORAGE_POSITION;\n        assembly {\n            bs.slot := position\n        }\n    }\n}\n"
    },
    "contracts/06-Reward/RewardPoll.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Reward Poll\n* @author Evert Kors <evert@thx.network>\n* @notice Extends base polls with reward information.\n* \n* Implementations:\n* TMP-6 Base poll: https://github.com/thxprotocol/modules/issues/6\n* TMP-8 Rewards: https://github.com/thxprotocol/modules/issues/8\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/EnumerableSet.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\n// Implements\nimport '../util/BasePoll.sol'; // TMP1, TMP 6\nimport '../TMP/TMP6/LibBasePollStorage.sol';\nimport '../TMP/TMP8/IRewardPoll.sol';\nimport '../TMP/TMP8/LibRewardPollStorage.sol';\n\ncontract RewardPoll is BasePoll, IRewardPoll {\n    uint256 constant ENABLE_REWARD = 2**250;\n    uint256 constant DISABLE_REWARD = 2**251;\n\n    modifier isReward {\n        LibBasePollStorage.BasePollStorage storage bData = baseData();\n\n        LibRewardPollStorage.RewardPollStorage storage rwPollData = LibRewardPollStorage.rewardPollStorageId(bData.id);\n\n        require(rwPollData.withdrawAmount != 0, 'NOT_REWARD_POLL');\n        _;\n    }\n\n    function voteValidate(address _voter) internal view override {\n        require(_isMember(_voter), 'NO_MEMBER');\n    }\n\n    /**\n     * @dev callback called after poll finalization\n     * @param _id ID of the reward poll\n     */\n    function onPollFinish(uint256 _id) internal override {\n        LibRewardPollStorage.RewardPollStorage storage rwPollData = LibRewardPollStorage.rewardPollStorageId(_id);\n\n        LibRewardPollStorage.Reward storage reward =\n            LibRewardPollStorage.rewardStorage().rewards[rwPollData.rewardIndex];\n\n        bool approved = _rewardPollApprovalState();\n        if (approved) {\n            if (rwPollData.withdrawAmount == ENABLE_REWARD) {\n                reward.state = LibRewardPollStorage.RewardState.Enabled;\n                emit RewardPollEnabled(_id);\n            } else if (rwPollData.withdrawAmount == DISABLE_REWARD) {\n                reward.state = LibRewardPollStorage.RewardState.Disabled;\n                emit RewardPollDisabled(_id);\n            } else {\n                // initial state\n                if (reward.withdrawAmount == 0 && reward.withdrawDuration == 0) {\n                    reward.state = LibRewardPollStorage.RewardState.Enabled;\n                    emit RewardPollEnabled(_id);\n                }\n                reward.withdrawAmount = rwPollData.withdrawAmount;\n                reward.withdrawDuration = rwPollData.withdrawDuration;\n                emit RewardPollUpdated(_id, reward.withdrawAmount, reward.withdrawDuration);\n            }\n        }\n        emit RewardPollFinalized(_id, approved);\n        delete reward.pollId;\n        delete rwPollData.withdrawAmount;\n        delete rwPollData.withdrawDuration;\n    }\n\n    /**\n     * @param _id ID of the reward\n     * @return The amound a member can withdraw for this reward.\n     */\n    function getWithdrawAmount(uint256 _id) external view override returns (uint256) {\n        return LibRewardPollStorage.rewardPollStorageId(_id).withdrawAmount;\n    }\n\n    /**\n     * @param _id ID of the reward\n     * @return The duration of the optional withdraw poll for this reward.\n     */\n    function getWithdrawDuration(uint256 _id) external view override returns (uint256) {\n        return LibRewardPollStorage.rewardPollStorageId(_id).withdrawDuration;\n    }\n\n    /**\n     * @param _id ID of the reward\n     * @return The storage index of the reward.\n     */\n    function getRewardIndex(uint256 _id) external view override returns (uint256) {\n        return LibRewardPollStorage.rewardPollStorageId(_id).rewardIndex;\n    }\n\n    /**\n     * @param _agree Bool reflecting vote for the poll\n     * @dev calls generic vote() function and emits reward poll specific event.\n     */\n    function _rewardPollVote(bool _agree) external override isReward isSelf {\n        vote(_agree);\n        emit RewardPollVoted(baseData().id, _msgSender(), _agree);\n    }\n\n    /**\n     * @dev calls abstract revokeVote() function and emits reward poll specific event.\n     */\n    function _rewardPollRevokeVote() external override isReward isSelf {\n        revokeVote();\n        emit RewardPollRevokedVote(baseData().id, _msgSender());\n    }\n\n    function _rewardPollFinalize() external override isReward isSelf {\n        finalize();\n    }\n\n    function _rewardPollApprovalState() public view virtual override isReward isSelf returns (bool) {\n        LibBasePollStorage.BasePollStorage storage bData = baseData();\n        return bData.yesCounter > bData.noCounter;\n    }\n}\n"
    },
    "contracts/util/BasePoll.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport '../TMP/TMP6/LibBasePollStorage.sol';\nimport './Access.sol'; // TMP 1\n\nabstract contract BasePoll is Access {\n    using SafeMath for uint256;\n\n    modifier isSelf {\n        require(msg.sender == address(this));\n        _;\n    }\n\n    function onPollFinish(uint256 _id) internal virtual;\n\n    function voteValidate(address _voter) internal virtual;\n\n    modifier checkTime() {\n        LibBasePollStorage.BasePollStorage storage bData = baseData();\n        require(block.timestamp >= bData.startTime && block.timestamp <= bData.endTime, 'IS_NO_VALID_TIME');\n        _;\n    }\n\n    /**\n     * @notice Finalize poll and call onPollFinish callback with result\n     */\n    function finalize() internal {\n        LibBasePollStorage.BasePollStorage storage bData = baseData();\n        require(block.timestamp >= bData.endTime, 'WRONG_STATE');\n        onPollFinish(bData.id);\n        delete bData.id;\n        delete bData.startTime;\n        delete bData.endTime;\n        delete bData.yesCounter;\n        delete bData.noCounter;\n        delete bData.totalVoted;\n        //delete bData.votesByAddress;\n    }\n\n    /**\n     * @dev callback called after poll finalization\n     * @param _agree True if user endorses the proposal else False\n     */\n    function vote(bool _agree) internal checkTime {\n        voteValidate(_msgSender());\n        LibBasePollStorage.BasePollStorage storage bData = baseData();\n\n        require(bData.votesByAddress[_msgSender()].time == 0, 'HAS_VOTED');\n        uint256 voiceWeight = 1;\n\n        if (_agree) {\n            bData.yesCounter = bData.yesCounter.add(voiceWeight);\n        } else {\n            bData.noCounter = bData.noCounter.add(voiceWeight);\n        }\n\n        bData.votesByAddress[_msgSender()].time = block.timestamp;\n        bData.votesByAddress[_msgSender()].weight = voiceWeight;\n        bData.votesByAddress[_msgSender()].agree = _agree;\n\n        bData.totalVoted = bData.totalVoted.add(1);\n    }\n\n    /**\n     * @notice Revoke user`s vote\n     */\n    function revokeVote() internal checkTime {\n        LibBasePollStorage.BasePollStorage storage bData = baseData();\n        address _voter = _msgSender();\n\n        require(bData.votesByAddress[_voter].time > 0, 'HAS_NOT_VOTED');\n\n        uint256 voiceWeight = bData.votesByAddress[_voter].weight;\n        bool agree = bData.votesByAddress[_voter].agree;\n\n        bData.votesByAddress[_voter].time = 0;\n        bData.votesByAddress[_voter].weight = 0;\n        bData.votesByAddress[_voter].agree = false;\n\n        bData.totalVoted = bData.totalVoted.sub(1);\n        if (agree) {\n            bData.yesCounter = bData.yesCounter.sub(voiceWeight);\n        } else {\n            bData.noCounter = bData.noCounter.sub(voiceWeight);\n        }\n    }\n\n    function baseData() internal pure returns (LibBasePollStorage.BasePollStorage storage) {\n        return LibBasePollStorage.basePollStorage(bps());\n    }\n\n    /**\n     * @dev This function gets the poll ID of message data that is appended with an address\n     */\n    function bps() internal pure returns (bytes32 rt) {\n        // These fields are not accessible from assembly\n        bytes memory array = msg.data;\n        // minus address space\n        uint256 index = msg.data.length - 20;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            rt := mload(add(array, index))\n        }\n    }\n}\n"
    },
    "contracts/util/Access.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.4;\n\n/******************************************************************************\\\n* @title Access\n* @author Evert Kors <evert@thx.network>\n* @notice Implement role-based access control.\n* \n* @dev\n* Implementations: \n* TMP-1 Access Control: https://github.com/thxprotocol/modules/issues/1\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/utils/EnumerableSet.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\n// depends on\nimport '../TMP/TMP1/IAccessControlEvents.sol';\nimport '../TMP/TMP1/LibAccessStorage.sol';\n\nimport '../TMP/RelayReceiver.sol';\n\ncontract Access is RelayReceiver, IAccessControlEvents {\n    //\n    // Access control view methods internal\n    //\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    modifier onlyOwner() {\n        require(LibDiamond.contractOwner() == _msgSender(), 'NOT_OWNER');\n        _;\n    }\n\n    modifier onlyManager() {\n        require(_hasRole(MANAGER_ROLE, _msgSender()), 'NOT_MANAGER');\n        _;\n    }\n\n    modifier onlyMember() {\n        require(_hasRole(MEMBER_ROLE, _msgSender()), 'NOT_MEMBER');\n        _;\n    }\n\n    /**\n     * @dev Checks if account bears role.\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     * @return if role member storage array contains the given account address.\n     */\n    function _hasRole(bytes32 role, address account) internal view virtual returns (bool) {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        return rs.roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Called in initialize methods.\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Called during initialization\n     * @param role Bytes32 array representing the role.\n     * @param adminRole Address of the role admin\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        emit RoleAdminChanged(role, rs.roles[role].adminRole, adminRole);\n        rs.roles[role].adminRole = adminRole;\n    }\n\n    /**\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        if (rs.roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @param role Bytes32 array representing the role.\n     * @param account Address of the account\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        LibAccessStorage.RoleStorage storage rs = LibAccessStorage.roleStorage();\n\n        if (rs.roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    //\n    // Pool roles view methods internal\n    //\n    bytes32 internal constant DEFAULT_ADMIN_ROLE = 0x00;\n    bytes32 internal constant MEMBER_ROLE = keccak256('MEMBER_ROLE');\n    bytes32 internal constant MANAGER_ROLE = keccak256('MANAGER_ROLE');\n\n    function _isManager(address _account) internal view returns (bool) {\n        return _hasRole(MANAGER_ROLE, _account);\n    }\n\n    function _isMember(address _account) internal view returns (bool) {\n        return _hasRole(MEMBER_ROLE, _account) || _hasRole(MANAGER_ROLE, _account);\n    }\n\n    function _getOwner() internal view returns (address) {\n        return LibDiamond.contractOwner();\n    }\n}\n"
    },
    "contracts/10-RewardBypass/RewardByPoll.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Rewards (Bypass poll)\n* @author Evert Kors <evert@thx.network>\n* @dev Inherits default reward poll, but will always approve it.\n* \n* Implementations: \n* TMP-8 Rewards: https://github.com/thxprotocol/modules/issues/7\n/******************************************************************************/\n\nimport '../06-Reward/RewardPoll.sol';\n\ncontract RewardByPoll is RewardPoll {\n    function _rewardPollApprovalState() public view virtual override isReward returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/06-Reward/Reward.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Reward Distribution\n* @author Evert Kors <evert@thx.network>\n* @notice Configure reward distribution.\n* \n* Implementations: \n* TMP-8 Rewards: https://github.com/thxprotocol/modules/issues/7\n* \n* Dependencies:\n* TMP-1 Access Control: https://github.com/thxprotocol/modules/issues/1\n* TMP-2 Member ID: https://github.com/thxprotocol/modules/issues/2\n* TMP-6 Base Poll: https://github.com/thxprotocol/modules/issues/6\n* TMP-7 Withdrawal: https://github.com/thxprotocol/modules/issues/6\n/******************************************************************************/\n\n// Implements\nimport '../TMP/TMP8/IReward.sol';\nimport '../TMP/TMP8/LibRewardPollStorage.sol';\n\n// Depends on\nimport '../util/Access.sol'; // TMP 1\nimport '../TMP/TMP2/LibMemberAccessStorage.sol';\nimport '../TMP/TMP7/LibWithdrawPollStorage.sol';\nimport '../TMP/TMP7/IWithdrawEvents.sol';\nimport '../util/BasePoll.sol'; // TMP1, TMP 6\nimport '../TMP/TMP6/LibBasePollStorage.sol';\n\ncontract Reward is Access, IReward, IWithdrawEvents {\n    /**\n     * @param _duration The duration of the reward poll\n     */\n    function setRewardPollDuration(uint256 _duration) external override onlyManager {\n        LibRewardPollStorage.rewardStorage().rewardPollDuration = _duration;\n    }\n\n    /**\n     * @return the default reward poll duration\n     */\n    function getRewardPollDuration() external view override returns (uint256) {\n        return LibRewardPollStorage.rewardStorage().rewardPollDuration;\n    }\n\n    /**\n     * @param _id The ID of the reward\n     * @return the reward information\n     */\n    function getReward(uint256 _id) external view override returns (LibRewardPollStorage.Reward memory) {\n        return LibRewardPollStorage.rewardStorage().rewards[_id - 1];\n    }\n\n    /**\n     * @dev Claim a reward for another member\n     * @param _withdrawAmount The  amount to withdraw for this reward.\n     * @param _withdrawDuration The duration of the withdraw poll for this reward.\n     */\n    function addReward(uint256 _withdrawAmount, uint256 _withdrawDuration) external override onlyOwner {\n        require(_withdrawAmount != 0, 'NOT_VALID');\n        LibRewardPollStorage.Reward memory reward;\n\n        reward.id = LibRewardPollStorage.rewardStorage().rewards.length + 1;\n        reward.state = LibRewardPollStorage.RewardState.Disabled;\n        reward.pollId = _createRewardPoll(reward.id, _withdrawAmount, _withdrawDuration);\n        LibRewardPollStorage.rewardStorage().rewards.push(reward);\n    }\n\n    /**\n     * @dev Claim a reward for another member\n     * @param _id The ID of the reward to claim.\n     * @param _withdrawAmount The new amount to withdraw for this reward.\n     * @param _withdrawDuration The new duration of the withdraw poll for this reward.\n     */\n    function updateReward(\n        uint256 _id,\n        uint256 _withdrawAmount,\n        uint256 _withdrawDuration\n    ) external override onlyOwner {\n        // todo verify amount\n        require(_isMember(_msgSender()), 'NOT_MEMBER');\n        LibRewardPollStorage.Reward storage reward = LibRewardPollStorage.rewardStorage().rewards[_id - 1];\n\n        // storage will be deleted (e.g. set to default) after poll is finalized\n        require(reward.pollId == 0, 'IS_NOT_FINALIZED');\n        // setting both params to initial state is not allowed\n        // this is a reserverd state for new rewards\n        require(!(_withdrawAmount == 0 && _withdrawDuration == 0), 'NOT_ALLOWED');\n\n        require(\n            !(reward.withdrawAmount == _withdrawAmount && reward.withdrawDuration == _withdrawDuration),\n            'IS_EQUAL'\n        );\n\n        reward.pollId = _createRewardPoll(_id, _withdrawAmount, _withdrawDuration);\n    }\n\n    /**\n     * @dev Enable an existing reward, should be disabled and can only be called by managers.\n     * @param _id The ID of the reward to claim.\n     */\n    function enableReward(uint256 _id) external override onlyOwner {\n        require(_isManager(_msgSender()), 'NOT_MANAGER');\n\n        LibRewardPollStorage.Reward storage reward = LibRewardPollStorage.rewardStorage().rewards[_id - 1];\n        require(reward.state != LibRewardPollStorage.RewardState.Enabled, 'ALREADY_ENABLED');\n\n        reward.state = LibRewardPollStorage.RewardState.Enabled;\n    }\n\n    /**\n     * @dev Disable an existing reward, should be enabled and can only be called by managers.\n     * @param _id The ID of the reward to claim.\n     */\n    function disableReward(uint256 _id) external override onlyOwner {\n        require(_isManager(_msgSender()), 'NOT_MANAGER');\n\n        LibRewardPollStorage.Reward storage reward = LibRewardPollStorage.rewardStorage().rewards[_id - 1];\n        require(reward.state != LibRewardPollStorage.RewardState.Disabled, 'ALREADY_DISABLED');\n\n        reward.state = LibRewardPollStorage.RewardState.Disabled;\n    }\n\n    /**\n     * @notice Claim a reward for another member\n     * @param _id The ID of the reward to claim for the other member\n     */\n    function claimRewardFor(uint256 _id, address _beneficiary) public override {\n        require(_isMember(_msgSender()), 'NOT_MEMBER');\n        require(_isMember(_beneficiary), 'NOT_MEMBER');\n\n        LibRewardPollStorage.Reward memory current = LibRewardPollStorage.rewardStorage().rewards[_id - 1];\n\n        require(current.state == LibRewardPollStorage.RewardState.Enabled, 'IS_NOT_ENABLED');\n        _createWithdrawPoll(current.withdrawAmount, current.withdrawDuration, _beneficiary);\n    }\n\n    /**\n     * @notice Claim a reward\n     * @param _id The ID of the reward to claim\n     */\n    function claimReward(uint256 _id) external override {\n        claimRewardFor(_id, _msgSender());\n    }\n\n    /**\n     * @dev Starts a withdraw poll.\n     * @param _amount Size of the withdrawal\n     * @param _duration The duration the withdraw poll\n     * @param _beneficiary Beneficiary of the reward\n     */\n    function _createWithdrawPoll(\n        uint256 _amount,\n        uint256 _duration,\n        address _beneficiary\n    ) internal returns (uint256) {\n        LibBasePollStorage.BaseStorage storage bst = LibBasePollStorage.baseStorage();\n        bst.pollCounter = bst.pollCounter + 1;\n\n        LibBasePollStorage.BasePollStorage storage baseStorage = LibBasePollStorage.basePollStorageId(bst.pollCounter);\n\n        baseStorage.id = bst.pollCounter;\n        baseStorage.startTime = block.timestamp;\n        baseStorage.endTime = block.timestamp + _duration;\n\n        LibWithdrawPollStorage.WithdrawPollStorage storage wpStorage =\n            LibWithdrawPollStorage.withdrawPollStorageId(bst.pollCounter);\n\n        wpStorage.amount = _amount;\n        wpStorage.beneficiary = LibMemberAccessStorage.memberStorage().addressToMember[_beneficiary];\n\n        emit WithdrawPollCreated(bst.pollCounter, wpStorage.beneficiary);\n        return baseStorage.id;\n    }\n\n    /**\n     * @dev Starts a withdraw poll.\n     * @param _id The ID of the reward\n     * @param _withdrawAmount The amount the beneficiary may withdraw\n     * @param _withdrawDuration The duration of the withdraw poll\n     */\n    function _createRewardPoll(\n        uint256 _id,\n        uint256 _withdrawAmount,\n        uint256 _withdrawDuration\n    ) internal returns (uint256) {\n        LibBasePollStorage.BaseStorage storage bst = LibBasePollStorage.baseStorage();\n        bst.pollCounter = bst.pollCounter + 1;\n\n        LibBasePollStorage.BasePollStorage storage baseStorage = LibBasePollStorage.basePollStorageId(bst.pollCounter);\n\n        LibRewardPollStorage.RewardStorage storage rewardStorage = LibRewardPollStorage.rewardStorage();\n\n        LibRewardPollStorage.RewardPollStorage storage rpStorage =\n            LibRewardPollStorage.rewardPollStorageId(bst.pollCounter);\n\n        baseStorage.id = bst.pollCounter;\n        baseStorage.startTime = block.timestamp;\n        baseStorage.endTime = block.timestamp + rewardStorage.rewardPollDuration;\n\n        rpStorage.rewardIndex = _id - 1;\n        rpStorage.withdrawAmount = _withdrawAmount;\n        rpStorage.withdrawDuration = _withdrawDuration;\n\n        emit RewardPollCreated(bst.pollCounter, _msgSender(), _id, _withdrawAmount);\n        return baseStorage.id;\n    }\n}\n"
    },
    "contracts/TMP/TMP7/LibWithdrawPollStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\nlibrary LibWithdrawPollStorage {\n    bytes32 constant WITHDRAW_STORAGE = keccak256('diamond.contract.assetpool.withdrawpoll');\n\n    struct WithdrawStorage {\n        uint256 proposeWithdrawPollDuration;\n    }\n\n    function withdrawStorage() internal pure returns (WithdrawStorage storage bs) {\n        bytes32 position = WITHDRAW_STORAGE;\n        assembly {\n            bs.slot := position\n        }\n    }\n\n    struct WithdrawPollStorage {\n        uint256 beneficiary;\n        uint256 amount;\n        uint256 unlockDate;\n    }\n\n    function getPosition(uint256 _id) internal pure returns (bytes32) {\n        return keccak256(abi.encode('diamond.contract.assetpool.withdrawpoll', _id));\n    }\n\n    function withdrawPollStorage(bytes32 _pos) internal pure returns (WithdrawPollStorage storage bs) {\n        assembly {\n            bs.slot := _pos\n        }\n    }\n\n    function withdrawPollStorageId(uint256 _id) internal pure returns (WithdrawPollStorage storage bs) {\n        bytes32 position = getPosition(_id);\n        assembly {\n            bs.slot := position\n        }\n    }\n}\n"
    },
    "contracts/TMP/TMP7/IWithdrawEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\ninterface IWithdrawEvents {\n    event WithdrawPollCreated(uint256 id, uint256 indexed member);\n}\n"
    },
    "contracts/10-RewardBypass/RewardBy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Rewards (Bypass poll)\n* @author Evert Kors <evert@thx.network>\n* @dev Inherits default reward implementation.\n* \n* Implementations: \n* TMP-8 Rewards: https://github.com/thxprotocol/modules/issues/7\n/******************************************************************************/\n\nimport '../06-Reward/Reward.sol';\n\ncontract RewardBy is Reward {}\n"
    },
    "contracts/02-AccessControlMock/AccessControlMock.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol\n\npragma solidity >=0.6.0 <0.8.0;\n\n/******************************************************************************\\\n* @author Evert Kors <evert@thx.network>\n* @dev Only used during tests.\n* \n* Implementations: \n* TMP-1 Access Control: https://github.com/thxprotocol/modules/issues/1\n/******************************************************************************/\n\nimport '../TMP/TMP1/IAccessControl.sol';\nimport '../TMP/TMP1/IAccessControlEvents.sol';\n\ncontract AccessControlMock is IAccessControl, IAccessControlEvents {\n    // TODO, consider moving storage to lib, for diamond tests\n    bool hasRoleMock;\n\n    function mockHasRole(bool _value) external {\n        hasRoleMock = _value;\n    }\n\n    function hasRole(bytes32 role, address account) external view override returns (bool) {\n        return hasRoleMock;\n    }\n\n    uint256 getRoleMemberCountMock;\n\n    function mockGetRoleMemberCount(uint256 _value) external {\n        getRoleMemberCountMock = _value;\n    }\n\n    function getRoleMemberCount(bytes32 role) external view override returns (uint256) {\n        return getRoleMemberCountMock;\n    }\n\n    address getRoleMemberMock;\n\n    function mockGetRoleMember(address _value) external {\n        getRoleMemberMock = _value;\n    }\n\n    function getRoleMember(bytes32 role, uint256 index) external view override returns (address) {\n        return getRoleMemberMock;\n    }\n\n    bytes32 getRoleAdminMock;\n\n    function mockGetRoleAdmin(bytes32 _value) external {\n        getRoleAdminMock = _value;\n    }\n\n    function getRoleAdmin(bytes32 role) external view override returns (bytes32) {\n        return getRoleAdminMock;\n    }\n\n    function grantRole(bytes32 role, address account) external override {}\n\n    function revokeRole(bytes32 role, address account) external override {}\n\n    function renounceRole(bytes32 role, address account) external override {}\n}\n"
    },
    "contracts/05-Withdraw/WithdrawPoll.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Withdraw Poll\n* @author Evert Kors <evert@thx.network>\n* @notice Extends base polls with withdrawal information.\n* \n* Dependencies:\n* TMP-3 Member ID: https://github.com/thxprotocol/modules/issues/2\n* TMP-5 Token: https://github.com/thxprotocol/modules/issues/5\n* \n* Implementations:\n* TMP-6 Base poll: https://github.com/thxprotocol/modules/issues/6\n* TMP-7 Withdrawals: https://github.com/thxprotocol/modules/issues/7\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/EnumerableSet.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\nimport '../PoolRegistry/IPoolRegistry.sol';\n\n// Implements\nimport '../util/BasePoll.sol'; // TMP1, TMP 6\nimport '../TMP/TMP6/LibBasePollStorage.sol';\nimport '../TMP/TMP7/IWithdrawPoll.sol';\nimport '../TMP/TMP7/LibWithdrawPollStorage.sol';\n\n// depends on\nimport '../TMP/TMP5/LibTokenStorage.sol';\nimport '../TMP/TMP2/LibMemberAccessStorage.sol';\n\ncontract WithdrawPoll is BasePoll, IWithdrawPoll {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev used to check if poll is a withdrawPoll\n     */\n    modifier isWithdraw() {\n        LibBasePollStorage.BasePollStorage storage bData = baseData();\n\n        LibWithdrawPollStorage.WithdrawPollStorage storage wpPollData =\n            LibWithdrawPollStorage.withdrawPollStorageId(bData.id);\n        require(wpPollData.beneficiary != 0, 'NOT_WITHDRAW_POLL');\n        _;\n    }\n\n    /**\n     * @param _id The ID of the poll that should be finished.\n     * @dev callback called after poll finalization\n     */\n    function onPollFinish(uint256 _id) internal override {\n        bool approved = _withdrawPollApprovalState();\n\n        LibWithdrawPollStorage.WithdrawPollStorage storage wpPollData =\n            LibWithdrawPollStorage.withdrawPollStorageId(_id);\n\n        if (approved) {\n            LibTokenStorage.TokenStorage storage s = LibTokenStorage.tokenStorage();\n\n            IPoolRegistry registry = IPoolRegistry(s.registry);\n            uint256 fee = wpPollData.amount.mul(registry.feePercentage()).div(10**18);\n            if (fee > 0) {\n                // When balance is insufficient, safeTransfer will fail\n                // according to its design.\n                s.token.safeTransfer(registry.feeCollector(), fee);\n                // Skip this check for pools with 0 balance, since these\n                // might have connected an TokenUnlimitedAccount.\n                if (s.balance != 0 && s.balance >= fee) {\n                    s.balance = s.balance.sub(fee);\n                }\n                emit WithdrawFeeCollected(fee);\n            }\n\n            address benef = LibMemberAccessStorage.memberStorage().memberToAddress[wpPollData.beneficiary];\n            if (wpPollData.amount > 0) {\n                s.token.safeTransfer(benef, wpPollData.amount);\n                if (s.balance != 0 && s.balance >= wpPollData.amount) {\n                    s.balance = s.balance.sub(wpPollData.amount);\n                }\n                emit Withdrawn(_id, benef, wpPollData.amount);\n            }\n        }\n\n        emit WithdrawPollFinalized(_id, approved);\n        delete wpPollData.beneficiary;\n        delete wpPollData.amount;\n        delete wpPollData.unlockDate;\n    }\n\n    /**\n     * @param _voter Address of the manager account that casts the vote.\n     * @dev Only managers can vote for withdrawPolls.\n     */\n    function voteValidate(address _voter) internal view override {\n        require(_isManager(_voter), 'NO_MANAGER');\n    }\n\n    /**\n     * @param _id ID of the withdrawPoll to get the beneficiary for.\n     * @return address of the beneficicary of the reward.\n     */\n    function getBeneficiary(uint256 _id) external view override returns (uint256) {\n        return LibWithdrawPollStorage.withdrawPollStorageId(_id).beneficiary;\n    }\n\n    /**\n     * @param _id ID of the withdrawPoll to get the reward size for.\n     * @return size of the withdrawal.\n     */\n    function getAmount(uint256 _id) external view override returns (uint256) {\n        return LibWithdrawPollStorage.withdrawPollStorageId(_id).amount;\n    }\n\n    /**\n     * @param _id ID of the withdrawPoll to get the reward size for.\n     * @return unlockDate of the withdrawal.\n     */\n    function getUnlockDate(uint256 _id) external view override returns (uint256) {\n        return LibWithdrawPollStorage.withdrawPollStorageId(_id).unlockDate;\n    }\n\n    function _withdrawPollVote(bool _agree) external override isWithdraw isSelf {\n        vote(_agree);\n        emit WithdrawPollVoted(baseData().id, _msgSender(), _agree);\n    }\n\n    function _withdrawPollRevokeVote() external override isWithdraw isSelf {\n        revokeVote();\n        emit WithdrawPollRevokedVote(baseData().id, _msgSender());\n    }\n\n    function _withdrawPollFinalize() external override isWithdraw isSelf {\n        LibBasePollStorage.BasePollStorage storage bData = baseData();\n        LibWithdrawPollStorage.WithdrawPollStorage storage wpPollData =\n            LibWithdrawPollStorage.withdrawPollStorageId(bData.id);\n        require(block.timestamp > wpPollData.unlockDate, 'TOO_SOON_TO_FINALIZE_THE_POLL');\n        finalize();\n    }\n\n    function _withdrawPollApprovalState() public view virtual override isWithdraw isSelf returns (bool) {\n        LibBasePollStorage.BasePollStorage storage bData = baseData();\n        return bData.yesCounter > bData.noCounter;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/TMP/TMP5/LibTokenStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nlibrary LibTokenStorage {\n    bytes32 constant TOKEN_STORAGE_POSITION = keccak256('diamond.standard.token.storage');\n\n    struct TokenStorage {\n        address registry;\n        uint256 balance;\n        IERC20 token;\n    }\n\n    function tokenStorage() internal pure returns (TokenStorage storage ts) {\n        bytes32 position = TOKEN_STORAGE_POSITION;\n        assembly {\n            ts.slot := position\n        }\n    }\n}\n"
    },
    "contracts/09-WithdrawBypass/WithdrawByPoll.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Withdrawals (Bypass poll)\n* @author Evert Kors <evert@thx.network>\n* @dev Inherits default withdraw poll, but will always approve it.\n* \n* Implementations: \n* TMP-7 Withdrawals: https://github.com/thxprotocol/modules/issues/7\n/******************************************************************************/\n\nimport '../05-Withdraw/WithdrawPoll.sol';\n\ncontract WithdrawByPoll is WithdrawPoll {\n    function _withdrawPollApprovalState() public view override isWithdraw returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/05-Withdraw/Withdraw.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Withdraw Proposal\n* @author Evert Kors <evert@thx.network>\n* @notice Create and propose withdrawals.\n* \n* Implementations: \n* TMP-7 Withdrawals: https://github.com/thxprotocol/modules/issues/7\n* \n* Dependencies:\n* TMP-6 Base Poll: https://github.com/thxprotocol/modules/issues/6\n* TMP-2 Member Control: https://github.com/thxprotocol/modules/issues/2\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/utils/EnumerableSet.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\n// Implements\nimport '../TMP/TMP7/IWithdraw.sol';\nimport '../TMP/TMP7/LibWithdrawPollStorage.sol';\n\n// Depends on\nimport '../TMP/TMP6/LibBasePollStorage.sol';\nimport '../TMP/TMP2/LibMemberAccessStorage.sol';\nimport '../util/Access.sol'; // TMP 1\n\ncontract Withdraw is Access, IWithdraw {\n    /**\n     * @notice Proposes a withdraw poll with the default withdrawPollDuration.\n     * @param _amount Size of the proposed withdrawal.\n     * @param _beneficiary Beneficiary of the reward.\n     * @param _unlockDate Date beyond which it will be possible to withdraw\n     */\n    function proposeWithdraw(uint256 _amount, address _beneficiary, uint256 _unlockDate) external override onlyOwner {\n        require(_amount != 0, 'NOT_VALID');\n\n        _createWithdrawPoll(\n            _amount,\n            LibWithdrawPollStorage.withdrawStorage().proposeWithdrawPollDuration,\n            _beneficiary,\n            _unlockDate\n        );\n    }\n\n    /**\n     * @notice Proposes a withdraw poll with the default withdrawPollDuration in bulk.\n     * @param _amounts Sizes of the proposed withdrawal.\n     * @param _beneficiaries Beneficiaries of the reward.\n     * @param _unlockDate Date beyond which it will be possible to withdraw\n     */\n    function proposeBulkWithdraw(uint256[] memory _amounts, address[] memory _beneficiaries, uint256 _unlockDate)\n        external\n        override\n        onlyOwner\n    {\n        require(_amounts.length != 0, 'INVALID_INPUT');\n        require(_beneficiaries.length != 0, 'INVALID_INPUT');\n        require(_amounts.length == _beneficiaries.length, 'INVALID_INPUT');\n\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\n            require(_amounts[i] != 0, 'NOT_VALID');\n            require(_beneficiaries[i] != address(0), 'NOT_VALID');\n            _createWithdrawPoll(\n                _amounts[i],\n                LibWithdrawPollStorage.withdrawStorage().proposeWithdrawPollDuration,\n                _beneficiaries[i],\n                _unlockDate\n            );\n        }\n    }\n\n    /**\n     * @notice Starts a withdraw poll.\n     * @param _amount Size of the withdrawal.\n     * @param _duration The duration the withdraw poll.\n     * @param _beneficiary Beneficiary of the reward.\n     * @param _unlockDate Date beyond which it will be possible to withdraw\n     */\n    function _createWithdrawPoll(\n        uint256 _amount,\n        uint256 _duration,\n        address _beneficiary,\n        uint256 _unlockDate\n    ) internal returns (uint256) {\n        LibBasePollStorage.BaseStorage storage bst = LibBasePollStorage.baseStorage();\n        bst.pollCounter = bst.pollCounter + 1;\n\n        LibBasePollStorage.BasePollStorage storage baseStorage = LibBasePollStorage.basePollStorageId(bst.pollCounter);\n        baseStorage.id = bst.pollCounter;\n        baseStorage.startTime = block.timestamp;\n        baseStorage.endTime = block.timestamp + _duration;\n\n        LibWithdrawPollStorage.WithdrawPollStorage storage wpStorage =\n            LibWithdrawPollStorage.withdrawPollStorageId(bst.pollCounter);\n\n        LibMemberAccessStorage.MemberStorage storage ms = LibMemberAccessStorage.memberStorage();\n        if (!_hasRole(MEMBER_ROLE, _beneficiary)) {\n            ms.memberCounter += 1;\n            ms.addressToMember[_beneficiary] = ms.memberCounter;\n            ms.memberToAddress[ms.memberCounter] = _beneficiary;\n            _grantRole(MEMBER_ROLE, _beneficiary);\n        }\n\n        wpStorage.beneficiary = ms.addressToMember[_beneficiary];\n        wpStorage.amount = _amount;\n        wpStorage.unlockDate = _unlockDate;\n\n        emit WithdrawPollCreated(bst.pollCounter, wpStorage.beneficiary);\n    }\n\n    /**\n     * @param _duration Default duration of the poll for proposed withdrawals.\n     */\n    function setProposeWithdrawPollDuration(uint256 _duration) external override onlyManager {\n        LibWithdrawPollStorage.withdrawStorage().proposeWithdrawPollDuration = _duration;\n    }\n\n    /**\n     * @return default duration in seconds for polls for proposed withdrawals.\n     */\n    function getProposeWithdrawPollDuration() external view override returns (uint256) {\n        return LibWithdrawPollStorage.withdrawStorage().proposeWithdrawPollDuration;\n    }\n}\n"
    },
    "contracts/09-WithdrawBypass/WithdrawBy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Withdrawals (Bypass poll)\n* @author Evert Kors <evert@thx.network>\n* @dev Inherits default withdraw implementation\n* \n* Implementations: \n* TMP-7 Withdrawals: https://github.com/thxprotocol/modules/issues/7\n/******************************************************************************/\n\nimport '../05-Withdraw/Withdraw.sol';\n\ncontract WithdrawBy is Withdraw {}\n"
    },
    "contracts/util/ExampleToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.4;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract ExampleToken is ERC20 {\n    constructor(address to, uint256 amount) ERC20('THX Token', 'THX') {\n        _mint(to, amount);\n    }\n}\n"
    },
    "contracts/04-Token/Token.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.0;\n\n/******************************************************************************\\\n* @title Asset Pool ERC20 asset type.\n* @author Evert Kors <evert@thx.network>\n* @notice Connect and deposit ERC20 assets.\n* \n* Implementations: \n* TMP-5 Token: https://github.com/thxprotocol/modules/issues/5\n/******************************************************************************/\n\nimport '@openzeppelin/contracts/token/ERC20/SafeERC20.sol';\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\nimport 'diamond-2/contracts/libraries/LibDiamond.sol';\n\nimport '../PoolRegistry/IPoolRegistry.sol';\nimport '../TMP/RelayReceiver.sol';\nimport '../TMP/TMP5/IToken.sol';\nimport '../TMP/TMP5/LibTokenStorage.sol';\n\ncontract Token is IToken, RelayReceiver {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @notice Sets registry address for the asset pool.\n     * @param _registry Address of the registry contract.\n     * @dev Registry contains general pool settings and will be governable at some point.\n     */\n    function setPoolRegistry(address _registry) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibTokenStorage.tokenStorage().registry = _registry;\n        emit RegistryUpdated(address(0), _registry);\n    }\n\n    /**\n     * @return address of the registry contract of the asset pool.\n     */\n    function getPoolRegistry() external view override returns (address) {\n        return LibTokenStorage.tokenStorage().registry;\n    }\n\n    /**\n     * @return pool token balance for the asset pool\n     */\n    function getBalance() external view override returns (uint256) {\n        return LibTokenStorage.tokenStorage().balance;\n    }\n\n    /**\n     * @notice Calculates the deposit fee over the amount and substracts of the total. Fee is transfered to FeeCollector address as stored in the registry.\n     * @param _amount Deposit amount to transfer to the pool.\n     * @dev Make sure a transfer for the given amount is approved before calling.\n     */\n    function deposit(uint256 _amount) external override {\n        require(_amount > 0, 'ZERO_AMOUNT');\n        LibTokenStorage.TokenStorage storage s = LibTokenStorage.tokenStorage();\n\n        IPoolRegistry registry = IPoolRegistry(s.registry);\n\n        uint256 fee = _amount.mul(registry.feePercentage()).div(10**18);\n        uint256 amount = _amount.sub(fee);\n\n        if (fee > 0) {\n            s.token.safeTransferFrom(_msgSender(), registry.feeCollector(), fee);\n            emit DepositFeeCollected(fee);\n        }\n        s.balance = s.balance.add(amount);\n        s.token.safeTransferFrom(_msgSender(), address(this), amount);\n        emit Depositted(_msgSender(), amount);\n    }\n\n    /**\n     * @param _token Address of the ERC20 contract to use in the asset pool.\n     * @dev Can only be set once.\n     */\n    function addToken(address _token) external override {\n        require(LibTokenStorage.tokenStorage().token == IERC20(0), 'INIT');\n        require(_token != address(0), 'ZERO');\n\n        LibDiamond.enforceIsContractOwner();\n        LibTokenStorage.tokenStorage().token = IERC20(_token);\n        emit TokenUpdated(address(0), _token);\n    }\n\n    /// @return address of the ERC20 contract used in the asset pool.\n    function getToken() external view override returns (address) {\n        return address(LibTokenStorage.tokenStorage().token);\n    }\n}\n"
    },
    "contracts/05-Withdraw/WithdrawPollProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Withdraw Poll Proxy\n* @author Evert Kors <evert@thx.network>\n* @notice Supports relayed withdraw poll calls.\n* \n* Implementations:\n* TMP-6 Base poll: https://github.com/thxprotocol/modules/issues/6\n* TMP-7 Withdrawals: https://github.com/thxprotocol/modules/issues/7\n/******************************************************************************/\n\nimport '../TMP/TMP7/IWithdrawPollProxy.sol';\nimport '../TMP/TMP6/LibBasePollStorage.sol';\n\nimport '../TMP/RelayReceiver.sol';\n\ncontract WithdrawPollProxy is IWithdrawPollProxy, RelayReceiver {\n    function withdrawPollVote(uint256 _id, bool _agree) external override {\n        bytes32 position = LibBasePollStorage.getPosition(_id);\n        bytes4 sig = bytes4(keccak256('_withdrawPollVote(bool)'));\n        bytes memory _call = abi.encodeWithSelector(sig, _agree);\n\n        (bool success, bytes memory data) = address(this).call(abi.encodePacked(_call, position, _msgSender()));\n        require(success, string(data));\n    }\n\n    function withdrawPollRevokeVote(uint256 _id) external override {\n        bytes32 position = LibBasePollStorage.getPosition(_id);\n        bytes4 sig = bytes4(keccak256('_withdrawPollRevokeVote()'));\n        bytes memory _call = abi.encodeWithSelector(sig);\n\n        (bool success, bytes memory data) = address(this).call(abi.encodePacked(_call, position, _msgSender()));\n        require(success, string(data));\n    }\n\n    function withdrawPollFinalize(uint256 _id) external override {\n        bytes32 position = LibBasePollStorage.getPosition(_id);\n        bytes4 sig = bytes4(keccak256('_withdrawPollFinalize()'));\n        bytes memory _call = abi.encodeWithSelector(sig);\n\n        (bool success, bytes memory data) = address(this).call(abi.encodePacked(_call, position, _msgSender()));\n        require(success, string(data));\n    }\n\n    function withdrawPollApprovalState(uint256 _id) external view override returns (bool) {\n        bytes32 position = LibBasePollStorage.getPosition(_id);\n        bytes4 sig = bytes4(keccak256('_withdrawPollApprovalState()'));\n        bytes memory _call = abi.encodeWithSelector(sig);\n\n        (bool success, bytes memory data) = address(this).staticcall(abi.encodePacked(_call, position, _msgSender()));\n        require(success, string(data));\n        return abi.decode(data, (bool));\n    }\n}\n"
    },
    "contracts/09-WithdrawBypass/WithdrawByPollProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Withdrawals (Bypass poll)\n* @author Evert Kors <evert@thx.network>\n* @dev Inherits default withdraw poll proxy\n* \n* Implementations: \n* TMP-7 Withdrawals: https://github.com/thxprotocol/modules/issues/7\n/******************************************************************************/\n\nimport '../05-Withdraw/WithdrawPollProxy.sol';\n\ncontract WithdrawByPollProxy is WithdrawPollProxy {}\n"
    },
    "contracts/08-BasePoll/BasePollProxy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\npragma solidity ^0.7.4;\npragma experimental ABIEncoderV2;\n\n/******************************************************************************\\\n* @title Base Poll Proxy\n* @author Evert Kors <evert@thx.network>\n* @notice Expose base poll storage.\n* \n* Implementations: \n* TMP-6 Base Poll: https://github.com/thxprotocol/modules/issues/6\n/******************************************************************************/\n\nimport '../TMP/TMP6/LibBasePollStorage.sol';\nimport '../TMP/TMP6/IBasePoll.sol';\n\ncontract BasePollProxy is IBasePoll {\n    function getStartTime(uint256 _id) external view override returns (uint256) {\n        return LibBasePollStorage.basePollStorageId(_id).startTime;\n    }\n\n    function getEndTime(uint256 _id) external view override returns (uint256) {\n        return LibBasePollStorage.basePollStorageId(_id).endTime;\n    }\n\n    function getYesCounter(uint256 _id) external view override returns (uint256) {\n        return LibBasePollStorage.basePollStorageId(_id).yesCounter;\n    }\n\n    function getNoCounter(uint256 _id) external view override returns (uint256) {\n        return LibBasePollStorage.basePollStorageId(_id).noCounter;\n    }\n\n    function getTotalVoted(uint256 _id) external view override returns (uint256) {\n        return LibBasePollStorage.basePollStorageId(_id).totalVoted;\n    }\n\n    function getVoteByAddress(uint256 _id, address _address)\n        public\n        view\n        override\n        returns (LibBasePollStorage.Vote memory)\n    {\n        return LibBasePollStorage.basePollStorageId(_id).votesByAddress[_address];\n    }\n}\n"
    },
    "contracts/01-AccessControl/MockSetup.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n// source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol\n\nimport './AccessControl.sol';\n\npragma solidity >=0.6.0 <0.8.0;\n\ncontract MockSetup is AccessControl {\n    function setupMockAccess(bytes32[] memory roles, address[] memory addr) public {\n        require(roles.length == addr.length, 'UNEQUAL');\n        for (uint256 i = 0; i < roles.length; i++) {\n            _setupRole(roles[i], addr[i]);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}